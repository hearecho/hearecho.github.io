<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>静态调度 on Road to Final</title>
    <link>https://hearecho.github.io/tags/%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6/</link>
    <description>Recent content in 静态调度 on Road to Final</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 31 Aug 2021 15:33:49 +0800</lastBuildDate><atom:link href="https://hearecho.github.io/tags/%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HEFT算法 静态调度</title>
      <link>https://hearecho.github.io/post/heft%E7%AE%97%E6%B3%95-%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Tue, 31 Aug 2021 15:33:49 +0800</pubDate>
      
      <guid>https://hearecho.github.io/post/heft%E7%AE%97%E6%B3%95-%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6/</guid>
      <description>论文 《Performance-effective and low-complexity task scheduling for heterogeneous computing 》
 本文是异构平台的两种静态调度方法，分别是heft和cpop算法。
 模型符号    符号 意义     $\overline {w_i}$ 任务i的平均执行时间   $w_{i,j}$ 任务i在处理器j上的执行时间   $L$ 处理器通信模块启动时间   $L_m$ 处理器m的通信模块启动时间   $c_{i,k} = L_m + \frac{data_{i,k}}{B_{m,n}}$ 任务i和任务j的通信时间   $B_{m,n}$ 处理器m，n的单位时间通信量   $data_{i,k}$ 任务i和任务j的通信量   $EST(n_i,p_j) = max{avail[j], max_{n_m\in pred(n_i)} (AFT(n_m)+c_{m,j})}$ 任务i在处理器j上的最早启动时间   $EFT(n_i,p_j) = w_{i,j} + EST(n_i,p_j)$ 任务i在处理器j上的最早完成时间   $avail[j]$ 处理器j最早可用时间   $makespan = max{AFT(n_{exit})}$ dag的工作完成时间   $rank_u(n_i) = \overline {w_i} + max_{n_j \in succ(n_i)}(\overline {c_{i,j}}+rank_u(n_j)) $ 作为权重   $rank_d(n_i) = max_{n_j \in pred(ni)} {rankd(n_j) + \overline {w_j} + \overline {c_{j,i}}}$ 作为权重    算法 两个重要指标 $rank_{u}$  $rank_{u}$是从任务ni到出口节点关键路径的长度，是包括任务ni的计算耗时的。对于出口节点$rank_{u}$的值等于它的平均执行时间。</description>
    </item>
    
  </channel>
</rss>
