<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>树 on Road to Final</title>
    <link>https://hearecho.github.io/tags/%E6%A0%91/</link>
    <description>Recent content in 树 on Road to Final</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 10 Dec 2021 13:36:27 +0800</lastBuildDate><atom:link href="https://hearecho.github.io/tags/%E6%A0%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>树</title>
      <link>https://hearecho.github.io/post/%E6%A0%91/</link>
      <pubDate>Fri, 10 Dec 2021 13:36:27 +0800</pubDate>
      
      <guid>https://hearecho.github.io/post/%E6%A0%91/</guid>
      <description>树 树是一个大类 包括二叉树，二叉搜索树，AVL树，红黑树，N叉树等等。树的算法题大多都可以使用递归进行解决。
二叉树 二叉树是指的是节点有小于等于两个出度的树，二叉树算是最基本的树，很多算法题目也是在二叉树的基础上出题。
二叉树的遍历 二叉树的主要有四种遍历方式，前序遍历，中序遍历，后序遍历以及层次遍历。前中后序遍历指的都是根节点在遍历过程中的顺序位置。
前序遍历 前序遍历的顺序就是中前后，先访问根节点，之后再递归访问左子树最后是右子树。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // 递归实现 func preorderRecursive(root *TreeNode, res *[]int) { //递归方式 	if root == nil { return } *res = append(*res, root.Val) preorderRecursive(root.Left, res) preorderRecursive(root.Right, res) } // 使用栈来代替系统栈 func preorder(root *TreeNode) []int { //使用栈来代替系统栈 	//刚好和后续相反，只不过在加入栈的时候就进行了访问 	stack := make([]*TreeNode, 0) res := make([]int, 0) for len(stack) !</description>
    </item>
    
  </channel>
</rss>
